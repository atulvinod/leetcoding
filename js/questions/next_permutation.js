
function sortBetweenIndices(arr, startIndex, endIndex) {
    // Check if indices are valid
    if (
      !Array.isArray(arr) ||
      startIndex < 0 ||
      endIndex >= arr.length ||
      startIndex >= endIndex
    ) {
      return;
    }
  
    // Extract the portion of the array to be sorted
    const portionToSort = arr.slice(startIndex, endIndex + 1);
  
    // Sort the extracted portion
    portionToSort.sort((a, b) => a - b); // Change the comparator function as needed
  
    // Replace the sorted portion back into the original array
    arr.splice(startIndex, portionToSort.length, ...portionToSort);
  
    return arr;
  }
  

/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function (nums) {
    let do_swap = false;
    /**
     * Approach: starting from last digit, find the next larger number than itself
     * 
     */
    for (let i = nums.length - 1; i >= 0; i--) {
        let min = Number.MAX_SAFE_INTEGER;
        let index = -1;
        for (let j = i + 1; j < nums.length; j++) {
            // if we find such a number , then we swap that digit with the digit at i'th position
            if (nums[i] < nums[j] && nums[j] < min) {
                min = nums[j];
                do_swap = true;
                index = j;
            }
        }
        // after swapping, we sort the digits after i'th position, this will create the lowest number
        if (do_swap) {
            [nums[i], nums[index]] = [nums[index], nums[i]]
            sortBetweenIndices(nums, i+1,nums.length-1);
        }
    }

    // if there is no swap possible, then that implies that we are at the last permutation
    // hence the next possible permutation will be the starting permutation, which is the lowest number
    // and that can be generated by sorting all the numbers
    if (!do_swap) {
        nums.sort((a, b) => a - b);
    }
    // console.log(nums);
};


nextPermutation([2, 3, 1])